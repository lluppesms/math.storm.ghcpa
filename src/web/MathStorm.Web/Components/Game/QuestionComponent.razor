@rendermode InteractiveServer
@implements IDisposable

<div class="row">
    <div class="col">
        <div class="text-center mb-4">
            <h4>Question @(GameSession.CurrentQuestionIndex + 1) of @GameSession.Questions.Count</h4>
            <div class="progress mb-3">
                <div class="progress-bar" role="progressbar" 
                     style="width: @((GameSession.CurrentQuestionIndex + 1) * 100 / GameSession.Questions.Count)%"
                     aria-valuenow="@(GameSession.CurrentQuestionIndex + 1)" 
                     aria-valuemin="0" 
                     aria-valuemax="@GameSession.Questions.Count"></div>
            </div>
        </div>

        @if (GameSession.CurrentQuestion != null)
        {
            <div class="card">
                <div class="card-body text-center">
                    <div class="mb-4">
                        <h2 class="display-4 mb-3">@GameSession.CurrentQuestion.QuestionText = ?</h2>
                        <div class="mb-3">
                            <input @ref="answerInput" type="text" inputmode="decimal"
                                   value="@userAnswerText"
                                   @oninput="HandleInput"
                                   @onkeydown="HandleKeyDown"
                                   class="form-control form-control-lg text-center" 
                                   placeholder="Enter your answer"
                                   style="max-width: 300px; margin: 0 auto; border: 2px solid #007bff;"
                                   autocomplete="off"
                                   maxlength="10" />
                        </div>
                        <button class="btn btn-success btn-lg me-3" @onclick="SubmitAnswer" disabled="@(!userAnswer.HasValue)">
                            <i class="fas fa-check"></i> Submit Answer
                        </button>
                        <button class="btn btn-outline-secondary btn-lg" @onclick="CancelGame">
                            <i class="fas fa-times"></i> Cancel Game
                        </button>
                    </div>
                    
                    @if (GameSession.QuestionStartTime.HasValue)
                    {
                        <div class="mt-3">
                            <small class="text-muted">
                                <i class="fas fa-clock"></i> Time: @elapsedTime.ToString("F1")s
                            </small>
                        </div>
                    }
                </div>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public GameSession GameSession { get; set; } = new();
    [Parameter] public EventCallback<double> OnAnswerSubmitted { get; set; }
    [Parameter] public EventCallback OnGameCancelled { get; set; }

    private const int MaxInputLength = 10;
    private double? userAnswer;
    private string userAnswerText = string.Empty;
    private Timer? timer;
    private double elapsedTime;
    private ElementReference answerInput;
    private int currentQuestionIndex = -1;

    protected override void OnParametersSet()
    {
        userAnswer = null;
        userAnswerText = string.Empty;
        elapsedTime = 0;
        StartTimer();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Always focus when component renders or when we have a new question
        if (firstRender || currentQuestionIndex != GameSession.CurrentQuestionIndex)
        {
            currentQuestionIndex = GameSession.CurrentQuestionIndex;
            await FocusInputAsync();
        }
    }

    private async Task FocusInputAsync()
    {
        try
        {
            // Use a small delay to ensure the DOM is fully rendered
            await Task.Delay(50);
            await answerInput.FocusAsync();
        }
        catch
        {
            // If focus fails, try again after a longer delay
            try
            {
                await Task.Delay(200);
                await answerInput.FocusAsync();
            }
            catch
            {
                // Silently handle any focus exceptions
            }
        }
    }

    private void HandleInput(ChangeEventArgs e)
    {
        var inputValue = e.Value?.ToString() ?? string.Empty;
        
        // Limit to max length
        if (inputValue.Length > MaxInputLength)
        {
            inputValue = inputValue[..MaxInputLength];
        }
        
        // Allow only valid numeric input (digits, decimal point, and negative sign)
        if (IsValidNumericInput(inputValue))
        {
            userAnswerText = inputValue;
            userAnswer = double.TryParse(userAnswerText, out var result) ? result : null;
        }
        // If invalid, keep the previous valid value (effectively ignoring the input)
    }

    private static bool IsValidNumericInput(string input)
    {
        if (string.IsNullOrEmpty(input))
            return true;
        
        // Allow empty, negative sign only, or valid decimal numbers
        return input == "-" || input == "." || input == "-." || double.TryParse(input, out _);
    }

    private void StartTimer()
    {
        timer?.Dispose();
        timer = new Timer(UpdateTimer, null, 0, 100); // Update every 100ms
    }

    private void UpdateTimer(object? state)
    {
        if (GameSession.QuestionStartTime.HasValue)
        {
            elapsedTime = (DateTime.Now - GameSession.QuestionStartTime.Value).TotalSeconds;
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task SubmitAnswer()
    {
        // Use 0 as default if no answer is provided
        var answer = userAnswer ?? 0;
        timer?.Dispose();
        await OnAnswerSubmitted.InvokeAsync(answer);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SubmitAnswer();
        }
    }

    private async Task CancelGame()
    {
        timer?.Dispose();
        await OnGameCancelled.InvokeAsync();
    }

    public void Dispose()
    {
        timer?.Dispose();
    }
}